(load "~/.dotfiles/lib/lisp/mylib.lisp")

(defun first-board ()
  (let ((board (make-array '(8 8) :initial-element 'empty)))
    (setf (aref board 3 3) 'black)
    (setf (aref board 4 3) 'white)
    (setf (aref board 3 4) 'white)
    (setf (aref board 4 4) 'black)
    board))

(defun look-board (board)
 (dotimes (y 8)
    (dotimes (x 8)
      (case (aref board y x)
        (empty (princ "-"))
        (black (princ "o"))
        (white (princ "x")))
      (princ " "))
    (fresh-line)))

(defun look-status (board stone turn)
  (format t "TURN ~d BLACK ~d WHITE ~d~%~d TURN~%"
          turn (stone-num board 'black) (stone-num board 'white) stone)) 

(defun onelook (board point)
  (aref board (cdr point) (car point)))

(defun stone-num (board stone)
  (let ((acc 0))
    (dotimes (y 8)
      (dotimes (x 8)
        (if (eq (onelook board (cons x y)) stone) (incf acc))))
    acc))

(defun turn (stone point board)
  (when (eq (onelook board point) 'empty)
    (let* ((alldir'((-1 . -1) (-1 .  0) (-1 .  1) ( 0 . -1) ( 0 .  1)
                              ( 1 . -1) ( 1 .  0) ( 1 .  1)))
           (turnlist
             (remove nil
                     (apply #'append
                            (mapcar (lambda (x)
                                      (turn-onedir stone point board x))
                                    alldir)))))
      (if turnlist (cons point turnlist)))))

(defun turn-onedir (stone point board dir)
  (flet ((point-out (point)
           (or (< (car point) 0) (< (cdr point) 0)
               (>= (car point) 8) (>= (cdr point) 8)))
         (next-point (point dir)
           (cons (+ (car point) (car dir)) (+ (cdr point) (cdr dir)))))
    (labels ((f (stone point board dir acc)
               (cond ((point-out point) nil)
                     ((eq (onelook board point) 'empty) nil)
                     ((eq (onelook board point) stone) acc)
                     (t (f stone (next-point point dir) board dir
                           (cons point acc))))))
      (f stone (next-point point dir) board dir nil))))

(defun turnable-point (stone board)
  (let ((acc nil))
    (dotimes (y 8)
      (dotimes (x 8)
        (if (turn stone (cons x y) board)
            (push (cons x y) acc))))
    (reverse acc)))

(defun end? (board)
  (if (and (null (turnable-point 'black board))
           (null (turnable-point 'white board)))
      t
      (let ((acc t))
        (dotimes (y 8)
          (dotimes (x 8)
            (if (eq (onelook board (cons x y)) 'empty)
                (setf acc nil))))
        acc)))

(defun pass? (board stone)
  (if (null (turnable-point stone board))
      t))

(defun result (board)
  (let ((black (stone-num board 'black))
        (white (stone-num board 'white)))
    (look-board board)
    (format t "BLACK ~d WHITE ~d~%" black white)
    (cond ((> black white) (princ "Black Wins"))
          ((< black white) (princ "White Wins"))
          ((= black white) (princ "Draw Game")))))

(defun othello-read ()
  (let ((r (read)))
    (if (eq (keta r) 2)
        (apply #'cons (mapcar #'1- (numtolist r))))))

(defun write-point (x)
  (+ (* (car x) 10) (cdr x) 11))

(defun stone-change (stone)
  (if (eq stone 'black)
      'white
      'black))

(defun put (stone point board)
  (let ((b board))
    (dolist (x (turn stone point board))
      (setf (aref b (cdr x) (car x)) stone))
    b))

(defun gameplay (blackfnc whitefnc)
  (labels
    ((f (board stone turn bf wf)
       (if (end? board)
           (result board)
           (if (pass? board stone)
               (progn (fresh-line) (princ "Pass") (fresh-line)
                      (f board (stone-change stone) turn bf wf))
               (progn (look-board board)
                      (look-status board stone turn)
                      (let ((point (funcall (if (eq stone 'black) bf wf)
                                            board stone)))
                        (if point
                            (progn (princ (write-point point))
                                   (fresh-line)
                                   (f (put stone point board)
                                      (stone-change stone)
                                      (1+ turn) bf wf))
                            (f board stone turn bf wf))))))))
    (f (first-board) 'black 1 blackfnc whitefnc)))

(defun player (board stone)
  (let ((r (othello-read)))
    (cond ((null r) nil)
          ((null (turn stone r board)) nil)
          (t r))))

(defun bogo-othello (board stone)
  (car (random-list (turnable-point stone board))))

(defun normal (board stone)
  (let ((point-lst '((120 -20 20 5 5 20 -20 120)
                     (-20 -40 -5 -5 -5 -5 -40 -20)
                     (20 -5 15 3 3 15 -5 20)
                     (5 -5 3 3 3 3 -5 20)
                     (5 -5 3 3 3 3 -5 5)
                     (20 -5 15 3 3 15 -5 20)
                     (-20 -40 -5 -5 -5 -5 -40 -20)
                     (120 -20 20 5 5 20 -20 120)
                     )))))
